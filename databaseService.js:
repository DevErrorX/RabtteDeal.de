const { dealsRef } = require("./firebase");
const InputValidator = require("./inputValidator"); // Assuming you've moved this to a separate file

class DatabaseService {
  constructor() {
    this.dealsCache = new Map(); // For quick lookups
    this.activeDeals = []; // Cached active deals
    this.lastUpdate = 0;
    this.cacheTTL = 30000; // 30 seconds cache
  }

  async initialize() {
    // Set up realtime listener
    dealsRef.on("value", (snapshot) => {
      this._processSnapshot(snapshot);
    });

    // Initial load
    const snapshot = await dealsRef.once("value");
    this._processSnapshot(snapshot);
  }

  _processSnapshot(snapshot) {
    const now = Date.now();
    const dealsData = snapshot.val() || {};
    
    // Convert Firebase object to array
    const dealsArray = Object.keys(dealsData).map(key => ({
      id: key,
      ...dealsData[key]
    }));

    // Update cache
    this.dealsCache.clear();
    dealsArray.forEach(deal => {
      this.dealsCache.set(deal.id, deal);
    });

    // Filter active deals
    this.activeDeals = dealsArray.filter(deal => deal.timer > now);
    this.lastUpdate = now;
  }

  async getAllDeals() {
    if (Date.now() - this.lastUpdate > this.cacheTTL) {
      await this._refreshCache();
    }
    return Array.from(this.dealsCache.values());
  }

  async getActiveDeals() {
    if (Date.now() - this.lastUpdate > this.cacheTTL) {
      await this._refreshCache();
    }
    return this.activeDeals;
  }

  async getDealById(id) {
    if (this.dealsCache.has(id)) {
      return this.dealsCache.get(id);
    }
    const snapshot = await dealsRef.child(id).once("value");
    return snapshot.val();
  }

  async getDealBySlug(slug) {
    if (Date.now() - this.lastUpdate > this.cacheTTL) {
      await this._refreshCache();
    }
    
    // First try exact match
    let deal = Array.from(this.dealsCache.values())
      .find(d => d.slug === slug);
    
    if (!deal) {
      // Try partial match
      deal = Array.from(this.dealsCache.values())
        .find(d => slug.startsWith(d.slug) || d.slug.startsWith(slug));
    }
    
    return deal;
  }

  async addDeal(dealData) {
    const errors = InputValidator.validateDealData(dealData);
    if (errors.length > 0) {
      throw new Error(`Validation failed: ${errors.join(", ")}`);
    }

    const dealId = dealData.id || this._generateDealId();
    const slug = this._generateSlug(dealData.title);

    const completeDeal = {
      ...dealData,
      id: dealId,
      slug,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      isActive: true
    };

    await dealsRef.child(dealId).set(completeDeal);
    return completeDeal;
  }

  async updateDeal(dealId, updates) {
    const deal = await this.getDealById(dealId);
    if (!deal) {
      throw new Error("Deal not found");
    }

    const updatedDeal = {
      ...deal,
      ...updates,
      updatedAt: new Date().toISOString()
    };

    // Revalidate the updated deal
    const errors = InputValidator.validateDealData(updatedDeal);
    if (errors.length > 0) {
      throw new Error(`Validation failed: ${errors.join(", ")}`);
    }

    await dealsRef.child(dealId).update(updates);
    return updatedDeal;
  }

  async deleteDeal(dealId) {
    await dealsRef.child(dealId).remove();
    return true;
  }

  async _refreshCache() {
    const snapshot = await dealsRef.once("value");
    this._processSnapshot(snapshot);
  }

  _generateDealId() {
    return Date.now().toString() + Math.random().toString(36).substr(2, 4);
  }

  _generateSlug(title) {
    const sanitized = InputValidator.sanitizeText(title)
      .toLowerCase()
      .trim()
      .replace(/[^a-z\s-]/gi, '')
      .replace(/[\s_-]+/g, ' ');

    const words = sanitized.split(' ').filter(word => word.length > 0);
    const firstTwoWords = words.slice(0, 2).join('-');
    
    return firstTwoWords.substring(0, 30);
  }
}

// Singleton instance
const databaseService = new DatabaseService();
databaseService.initialize(); // Start the initialization

module.exports = databaseService;const { dealsRef } = require("./firebase");
const InputValidator = require("./inputValidator"); // Assuming you've moved this to a separate file

class DatabaseService {
  constructor() {
    this.dealsCache = new Map(); // For quick lookups
    this.activeDeals = []; // Cached active deals
    this.lastUpdate = 0;
    this.cacheTTL = 30000; // 30 seconds cache
  }

  async initialize() {
    // Set up realtime listener
    dealsRef.on("value", (snapshot) => {
      this._processSnapshot(snapshot);
    });

    // Initial load
    const snapshot = await dealsRef.once("value");
    this._processSnapshot(snapshot);
  }

  _processSnapshot(snapshot) {
    const now = Date.now();
    const dealsData = snapshot.val() || {};
    
    // Convert Firebase object to array
    const dealsArray = Object.keys(dealsData).map(key => ({
      id: key,
      ...dealsData[key]
    }));

    // Update cache
    this.dealsCache.clear();
    dealsArray.forEach(deal => {
      this.dealsCache.set(deal.id, deal);
    });

    // Filter active deals
    this.activeDeals = dealsArray.filter(deal => deal.timer > now);
    this.lastUpdate = now;
  }

  async getAllDeals() {
    if (Date.now() - this.lastUpdate > this.cacheTTL) {
      await this._refreshCache();
    }
    return Array.from(this.dealsCache.values());
  }

  async getActiveDeals() {
    if (Date.now() - this.lastUpdate > this.cacheTTL) {
      await this._refreshCache();
    }
    return this.activeDeals;
  }

  async getDealById(id) {
    if (this.dealsCache.has(id)) {
      return this.dealsCache.get(id);
    }
    const snapshot = await dealsRef.child(id).once("value");
    return snapshot.val();
  }

  async getDealBySlug(slug) {
    if (Date.now() - this.lastUpdate > this.cacheTTL) {
      await this._refreshCache();
    }
    
    // First try exact match
    let deal = Array.from(this.dealsCache.values())
      .find(d => d.slug === slug);
    
    if (!deal) {
      // Try partial match
      deal = Array.from(this.dealsCache.values())
        .find(d => slug.startsWith(d.slug) || d.slug.startsWith(slug));
    }
    
    return deal;
  }

  async addDeal(dealData) {
    const errors = InputValidator.validateDealData(dealData);
    if (errors.length > 0) {
      throw new Error(`Validation failed: ${errors.join(", ")}`);
    }

    const dealId = dealData.id || this._generateDealId();
    const slug = this._generateSlug(dealData.title);

    const completeDeal = {
      ...dealData,
      id: dealId,
      slug,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      isActive: true
    };

    await dealsRef.child(dealId).set(completeDeal);
    return completeDeal;
  }

  async updateDeal(dealId, updates) {
    const deal = await this.getDealById(dealId);
    if (!deal) {
      throw new Error("Deal not found");
    }

    const updatedDeal = {
      ...deal,
      ...updates,
      updatedAt: new Date().toISOString()
    };

    // Revalidate the updated deal
    const errors = InputValidator.validateDealData(updatedDeal);
    if (errors.length > 0) {
      throw new Error(`Validation failed: ${errors.join(", ")}`);
    }

    await dealsRef.child(dealId).update(updates);
    return updatedDeal;
  }

  async deleteDeal(dealId) {
    await dealsRef.child(dealId).remove();
    return true;
  }

  async _refreshCache() {
    const snapshot = await dealsRef.once("value");
    this._processSnapshot(snapshot);
  }

  _generateDealId() {
    return Date.now().toString() + Math.random().toString(36).substr(2, 4);
  }

  _generateSlug(title) {
    const sanitized = InputValidator.sanitizeText(title)
      .toLowerCase()
      .trim()
      .replace(/[^a-z\s-]/gi, '')
      .replace(/[\s_-]+/g, ' ');

    const words = sanitized.split(' ').filter(word => word.length > 0);
    const firstTwoWords = words.slice(0, 2).join('-');
    
    return firstTwoWords.substring(0, 30);
  }
}

// Singleton instance
const databaseService = new DatabaseService();
databaseService.initialize(); // Start the initialization

module.exports = databaseService;
